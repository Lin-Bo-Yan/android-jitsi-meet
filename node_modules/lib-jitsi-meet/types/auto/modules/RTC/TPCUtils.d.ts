export const HD_SCALE_FACTOR: 1;
export const LD_SCALE_FACTOR: 4;
export const SD_SCALE_FACTOR: 2;
export const SIM_LAYER_RIDS: string[];
/**
 * Handles track related operations on TraceablePeerConnection when browser is
 * running in unified plan mode.
 */
export class TPCUtils {
    /**
     * Creates a new instance for a given TraceablePeerConnection
     *
     * @param peerconnection - the tpc instance for which we have utility functions.
     */
    constructor(peerconnection: any);
    pc: any;
    codecSettings: any;
    /**
     * Calculates the configuration of the active encoding when the browser sends only one stream, i,e,, when there is
     * no spatial scalability configure (p2p) or when it is running in full SVC mode.
     *
     * @param {JitsiLocalTrack} localVideoTrack - The local video track.
     * @param {CodecMimeType} codec - The video codec.
     * @param {number} newHeight - The resolution that needs to be configured for the local video track.
     * @returns {Object} configuration.
     */
    _calculateActiveEncodingParams(localVideoTrack: any, codec: {
        AV1: string;
        H264: string;
        OPUS: string;
        ULPFEC: string;
        VP8: string;
        VP9: string;
    }, newHeight: number): any;
    /**
     * Obtains stream encodings that need to be configured on the given track based
     * on the track media type and the simulcast setting.
     * @param {JitsiLocalTrack} localTrack
     */
    _getStreamEncodings(localTrack: any): {
        active: any;
        maxBitrate: any;
        rid: string;
        scaleResolutionDownBy: number;
    }[] | ({
        active: any;
        maxBitrate: any;
        rid: string;
        scaleResolutionDownBy: number;
        scalabilityMode: string;
    } | {
        active: boolean;
        maxBitrate: number;
        rid?: undefined;
        scaleResolutionDownBy?: undefined;
        scalabilityMode?: undefined;
    })[] | {
        active: any;
        maxBitrate: any;
    }[] | {
        active: any;
    }[];
    /**
     * The startup configuration for the stream encodings that are applicable to
     * the video stream when a new sender is created on the peerconnection. The initial
     * config takes into account the differences in browser's simulcast implementation.
     *
     * Encoding parameters:
     * active - determine the on/off state of a particular encoding.
     * maxBitrate - max. bitrate value to be applied to that particular encoding
     *  based on the encoding's resolution and config.js videoQuality settings if applicable.
     * rid - Rtp Stream ID that is configured for a particular simulcast stream.
     * scaleResolutionDownBy - the factor by which the encoding is scaled down from the
     *  original resolution of the captured video.
     *
     * @param {VideoType} videoType
     * @param {String} codec
     */
    _getVideoStreamEncodings(videoType: VideoType, codec: string): {
        active: any;
        maxBitrate: any;
        rid: string;
        scaleResolutionDownBy: number;
    }[] | ({
        active: any;
        maxBitrate: any;
        rid: string;
        scaleResolutionDownBy: number;
        scalabilityMode: string;
    } | {
        active: boolean;
        maxBitrate: number;
        rid?: undefined;
        scaleResolutionDownBy?: undefined;
        scalabilityMode?: undefined;
    })[];
    /**
     * Returns a boolean indicating whether the video encoder is running in full SVC mode, i.e., it sends only one
     * video stream that has both temporal and spatial scalability.
     *
     * @param {CodecMimeType} codec
     * @returns boolean
     */
    _isRunningInFullSvcMode(codec: {
        AV1: string;
        H264: string;
        OPUS: string;
        ULPFEC: string;
        VP8: string;
        VP9: string;
    }): boolean;
    /**
     * Returns a boolean indicating whether the bitrate needs to be capped for the local video track if it happens to
     * be a screenshare track. The lower spatial layers for screensharing are disabled when low fps screensharing is in
     * progress. Sending all three streams often results in the browser suspending the high resolution in low b/w and
     * and low cpu conditions, especially on the low end machines. Suspending the low resolution streams ensures that
     * the highest resolution stream is available always. Safari is an exception here since it does not send the
     * desktop stream at all if only the high resolution stream is enabled.
     *
     * @param {JitsiLocalTrack} localVideoTrack - The local video track.
     * @returns {boolean}
     */
    _isScreenshareBitrateCapped(localVideoTrack: any): boolean;
    /**
     * Updates the sender parameters in the stream encodings.
     *
     * @param {RTCRtpSender} sender - the sender associated with a MediaStreamTrack.
     * @param {boolean} enable - whether the streams needs to be enabled or disabled.
     * @returns {Promise} - A promise that resolves when the operation is successful, rejected otherwise.
     */
    _updateSenderEncodings(sender: RTCRtpSender, enable: boolean): Promise<any>;
    /**
    * Adds {@link JitsiLocalTrack} to the WebRTC peerconnection for the first time.
    * @param {JitsiLocalTrack} track - track to be added to the peerconnection.
    * @param {boolean} isInitiator - boolean that indicates if the endpoint is offerer in a p2p connection.
    * @returns {void}
    */
    addTrack(localTrack: any, isInitiator: boolean): void;
    /**
     * Returns the calculated active state of the stream encodings based on the frame height requested for the send
     * stream. All the encodings that have a resolution lower than the frame height requested will be enabled.
     *
     * @param {JitsiLocalTrack} localVideoTrack The local video track.
     * @param {CodecMimeType} codec - The codec currently in use.
     * @param {number} newHeight The resolution requested for the video track.
     * @returns {Array<boolean>}
     */
    calculateEncodingsActiveState(localVideoTrack: any, codec: {
        AV1: string;
        H264: string;
        OPUS: string;
        ULPFEC: string;
        VP8: string;
        VP9: string;
    }, newHeight: number): Array<boolean>;
    /**
     * Returns the calculated max bitrates that need to be configured on the stream encodings based on the video
     * type and other considerations associated with screenshare.
     *
     * @param {JitsiLocalTrack} localVideoTrack The local video track.
     * @param {CodecMimeType} codec - The codec currently in use.
     * @param {number} newHeight The resolution requested for the video track.
     * @returns {Array<number>}
     */
    calculateEncodingsBitrates(localVideoTrack: any, codec: {
        AV1: string;
        H264: string;
        OPUS: string;
        ULPFEC: string;
        VP8: string;
        VP9: string;
    }, newHeight: number): Array<number>;
    /**
     * Returns the calculated scalability modes for the video encodings when scalability modes are supported.
     *
     * @param {JitsiLocalTrack} localVideoTrack The local video track.
     * @param {CodecMimeType} codec - The codec currently in use.
     * @param {number} maxHeight The resolution requested for the video track.
     * @returns {Array<VideoEncoderScalabilityMode> | undefined}
     */
    calculateEncodingsScalabilityMode(localVideoTrack: any, codec: {
        AV1: string;
        H264: string;
        OPUS: string;
        ULPFEC: string;
        VP8: string;
        VP9: string;
    }, maxHeight: number): Array<{
        L1T3: string;
        L2T3: string;
        L2T3_KEY: string;
        L3T3: string;
        L3T3_KEY: string;
    }> | undefined;
    /**
     * Returns the scale factor that needs to be applied on the local video stream based on the desired resolution
     * and the codec in use.
     *
     * @param {JitsiLocalTrack} localVideoTrack The local video track.
     * @param {CodecMimeType} codec - The codec currently in use.
     * @param {number} maxHeight The resolution requested for the video track.
     * @returns {number|undefined}
     */
    calculateEncodingsScaleFactor(localVideoTrack: any, codec: {
        AV1: string;
        H264: string;
        OPUS: string;
        ULPFEC: string;
        VP8: string;
        VP9: string;
    }, maxHeight: number): number | undefined;
    /**
     * Ensures that the ssrcs associated with a FID ssrc-group appear in the correct order, i.e.,
     * the primary ssrc first and the secondary rtx ssrc later. This is important for unified
     * plan since we have only one FID group per media description.
     * @param {Object} description the webRTC session description instance for the remote
     * description.
     * @private
     */
    private ensureCorrectOrderOfSsrcs;
    /**
     * Returns the max resolution that the client is configured to encode for a given local video track. The actual
     * send resolution might be downscaled based on cpu and bandwidth constraints.
     *
     * @param {JitsiLocalTrack} localVideoTrack - The local video track.
     * @param {CodecMimeType} codec - The codec currently in use.
     * @returns {number|null} The max encoded resolution for the given video track.
     */
    getConfiguredEncodeResolution(localVideoTrack: any, codec: {
        AV1: string;
        H264: string;
        OPUS: string;
        ULPFEC: string;
        VP8: string;
        VP9: string;
    }): number | null;
    /**
     * Takes in a *unified plan* offer and inserts the appropriate parameters for adding simulcast receive support.
     * @param {Object} desc - A session description object
     * @param {String} desc.type - the type (offer/answer)
     * @param {String} desc.sdp - the sdp content
     *
     * @return {Object} A session description (same format as above) object with its sdp field modified to advertise
     * simulcast receive support.
     */
    insertUnifiedPlanSimulcastReceive(desc: {
        type: string;
        sdp: string;
    }): any;
    /**
     * Returns a boolean indicating whether the video encoder is running in Simulcast mode, i.e., three encodings need
     * to be configured in 4:2:1 resolution order with temporal scalability.
     *
     * @param {CodecMimeType} codec - The video codec in use.
     * @returns {boolean}
     */
    isRunningInSimulcastMode(codec: {
        AV1: string;
        H264: string;
        OPUS: string;
        ULPFEC: string;
        VP8: string;
        VP9: string;
    }): boolean;
    /**
     * Replaces the existing track on a RTCRtpSender with the given track.
     *
     * @param {JitsiLocalTrack} oldTrack - existing track on the sender that needs to be removed.
     * @param {JitsiLocalTrack} newTrack - new track that needs to be added to the sender.
     * @returns {Promise<RTCRtpTransceiver>} - resolved with the associated transceiver when done, rejected otherwise.
     */
    replaceTrack(oldTrack: any, newTrack: any): Promise<RTCRtpTransceiver>;
    /**
     * Set the simulcast stream encoding properties on the RTCRtpSender.
     *
     * @param {JitsiLocalTrack} localTrack - the current track in use for which the encodings are to be set.
     * @returns {Promise<void>} - resolved when done.
     */
    setEncodings(localTrack: any): Promise<void>;
    /**
     * Resumes or suspends media on the peerconnection by setting the active state on RTCRtpEncodingParameters
     * associated with all the senders that have a track attached to it.
     *
     * @param {boolean} enable - whether outgoing media needs to be enabled or disabled.
     * @param {string} mediaType - media type, 'audio' or 'video', if neither is passed, all outgoing media will either
     * be enabled or disabled.
     * @returns {Promise} - A promise that is resolved when the change is succesful on all the senders, rejected
     * otherwise.
     */
    setMediaTransferActive(enable: boolean, mediaType: string): Promise<any>;
    /**
     * Ensures that the resolution of the stream encodings are consistent with the values
     * that were configured on the RTCRtpSender when the source was added to the peerconnection.
     * This should prevent us from overriding the default values if the browser returns
     * erroneous values when RTCRtpSender.getParameters is used for getting the encodings info.
     * @param {JitsiLocalTrack} localVideoTrack The local video track.
     * @param {Object} parameters - the RTCRtpEncodingParameters obtained from the browser.
     * @returns {void}
     */
    updateEncodingsResolution(localVideoTrack: any, parameters: any): void;
}
import { VideoType } from "../../service/RTC/VideoType";
